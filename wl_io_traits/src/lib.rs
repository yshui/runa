#![feature(type_alias_impl_trait)]
use std::{
    io::Result,
    os::fd::{BorrowedFd, RawFd},
    pin::Pin,
    task::{Context, Poll},
};
/// A extension trait of `AsyncWrite` that supports sending file descriptors
/// along with data.
pub trait AsyncWriteWithFd {
    /// Writes the given buffer and file descriptors to the stream.
    ///
    /// # Note
    ///
    /// To send file descriptors, usually at least one byte of data must be
    /// sent. Unless, for example, the implementation choose to buffer the
    /// file descriptors until flush is called. Check the documentation of
    /// the specific implementation to see if this is the case.
    ///
    /// # Returns
    ///
    /// Returns the number of bytes written on success. The file descriptors
    /// will all be sent as long as they don't exceed the maximum number of
    /// file descriptors that can be sent in a message, in which case an
    /// error is returned.
    fn poll_write_with_fds(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &[u8],
        fds: &[BorrowedFd<'_>],
    ) -> Poll<Result<usize>>;
}

impl<T: AsyncWriteWithFd + Unpin> AsyncWriteWithFd for &mut T {
    fn poll_write_with_fds(
        mut self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &[u8],
        fds: &[BorrowedFd<'_>],
    ) -> Poll<Result<usize>> {
        Pin::new(&mut **self).poll_write_with_fds(cx, buf, fds)
    }
}

/// A extension trait of `AsyncRead` that supports receiving file descriptors
/// along with data.
///
/// # Safety
///
/// At the minimum, the implementation cannot hold copies of the file
/// descriptors after they have been transferred to the caller. Additionally,
/// the file descriptors must be suitable for creating
/// [`std::unix::io::OwnedFd`].
pub unsafe trait AsyncReadWithFd {
    /// Reads data and file descriptors from the stream. This is generic over
    /// how you store the file descriptors. Use something like tinyvec if
    /// you want to avoid heap allocations.
    ///
    /// This cumbersome interface mainly originates from the fact kernel would
    /// drop file descriptors if you don't give it a buffer big enough.
    /// Otherwise it would be easy to have read_data and read_fd be separate
    /// functions.
    ///
    /// # Arguments
    ///
    /// * `fds`     : Storage for the file descriptors.
    /// * `fd_limit`: Maximum number of file descriptors to receive. If more are
    ///   received, they could be closed or stored in a buffer, depends on the
    ///   implementation. None means no limit.
    ///
    /// # Note
    ///
    /// If the `fds` buffer is too small to hold all the file descriptors, the
    /// extra file descriptors MAY be CLOSED. Some implementation might hold
    /// a buffer of file descriptors to prevent this from happening. You
    /// should check the documentation of the implementor.
    ///
    /// # Returns
    ///
    /// The number of bytes read and the number of file descriptors read,
    /// respectively.
    fn poll_read_with_fds(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &mut [u8],
        fds: &mut [RawFd],
    ) -> Poll<Result<(usize, usize)>>;
}

/// Forward impl of `AsyncReadWithFd` for `&mut T` where `T: AsyncReadWithFd`.
///
/// # Safety
///
/// `impl AsyncReadWithFd for T` is already unsafe, so we can assume it upholds
/// the contract of AsyncReadWithFd.
unsafe impl<T: AsyncReadWithFd + Unpin> AsyncReadWithFd for &mut T {
    fn poll_read_with_fds(
        mut self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &mut [u8],
        fds: &mut [RawFd],
    ) -> Poll<Result<(usize, usize)>> {
        Pin::new(&mut **self).poll_read_with_fds(cx, buf, fds)
    }
}

pub mod ser {
    use std::pin::Pin;

    /// A serialization trait, implemented by wayland message types.
    ///
    /// We can't use serde, because it doesn't support passing file descriptors.
    /// Most of the serialization code is expected to be generated by
    /// `wl_scanner`.
    ///
    /// For now instead of a Serializer trait, we take types that impls
    /// AsyncBufWriteWithFd directly, because we expect to only serialize to
    /// binary, but this might change in the future.
    pub trait Serialize {
        /// Serialize into the buffered writer. This function returns no errors,
        /// failures in seializing are generally program errors, and triggers
        /// panicking.
        ///
        /// # Panic
        ///
        /// If there is not enough space in the buffer, this function should
        /// panic - the user should have called `poll_reserve` before
        /// serializing, so this indicates programming error. If `self`
        /// contains file descriptors that aren't OwnedFd, this function
        /// panics too.
        fn serialize<W: super::buf::AsyncBufWriteWithFd>(self, writer: Pin<&mut W>);
        /// How many bytes will this message serialize to. Including the 8 byte
        /// header.
        fn len(&self) -> u16;
        /// How many file descriptors will this message serialize to.
        fn nfds(&self) -> u8;
    }
}

pub mod de {
    use std::os::fd::RawFd;

    pub trait Deserializer<'a>: Sized {
        /// Pop `len` bytes from the buffer, returns a slice of length `len`.
        /// The numnber of consumed bytes should be `len` aligned up to
        /// 4 bytes boundaries. This only affects the number of bytes
        /// consumed, the returned slice is not always `len` bytes long.
        fn pop_bytes(&mut self, len: usize) -> &'a [u8];
        fn pop_fd(&mut self) -> RawFd;
        #[inline]
        fn pop_i32(&mut self) -> i32 {
            let slice = self.pop_bytes(4);
            // Safety: slice is guaranteed to be 4 bytes long
            let ret = i32::from_ne_bytes(slice.try_into().unwrap());
            ret
        }

        #[inline]
        fn pop_u32(&mut self) -> u32 {
            let slice = self.pop_bytes(4);
            // Safety: slice is guaranteed to be 4 bytes long
            let ret = u32::from_ne_bytes(slice.try_into().unwrap());
            ret
        }
    }

    impl<'a, D: Deserializer<'a>> Deserializer<'a> for &'_ mut D {
        #[inline]
        fn pop_bytes(&mut self, len: usize) -> &'a [u8] {
            (**self).pop_bytes(len)
        }

        #[inline]
        fn pop_fd(&mut self) -> RawFd {
            (**self).pop_fd()
        }

        #[inline]
        fn pop_i32(&mut self) -> i32 {
            (**self).pop_i32()
        }

        #[inline]
        fn pop_u32(&mut self) -> u32 {
            (**self).pop_u32()
        }
    }

    pub enum Error {
        InvalidIntEnum(i32, &'static str),
        InvalidUintEnum(u32, &'static str),
        UnknownOpcode(u32, &'static str),
    }

    impl std::fmt::Debug for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Error::InvalidIntEnum(v, name) =>
                    write!(f, "int {} is not a valid value for {}", v, name),
                Error::InvalidUintEnum(v, name) =>
                    write!(f, "uint {} is not a valid value for {}", v, name),
                Error::UnknownOpcode(v, name) =>
                    write!(f, "opcode {} is not valid for {}", v, name),
            }
        }
    }

    impl std::fmt::Display for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            std::fmt::Debug::fmt(self, f)
        }
    }

    impl std::error::Error for Error {}

    pub trait Deserialize<'a>: Sized {
        fn deserialize<D: Deserializer<'a>>(deserializer: D) -> Result<Self, Error>;
    }
}

pub mod buf {
    use std::{future::Future, io::Result, os::fd::OwnedFd, task::ready};

    use super::*;
    /// Buffered I/O object for a stream of bytes with file descriptors.
    ///
    /// # Safety
    ///
    /// See [`crate::AsyncReadWithFd`]. Also, implementation cannot hold copies,
    /// or use any of the file descriptors after they are consumed by the
    /// caller.
    pub unsafe trait AsyncBufReadWithFd: AsyncReadWithFd {
        /// Reads enough data to return a buffer at least the given size.
        fn poll_fill_buf_until<'a>(
            self: Pin<&'a mut Self>,
            cx: &mut Context<'_>,
            len: usize,
        ) -> Poll<Result<()>>;
        /// Pop 1 file descriptor from the buffer, return None if the buffer is
        /// empty. This takes shared references, mainly because we want to have
        /// the deserialized value borrow from the BufReader, but while
        /// deserializing, we also need to pop file descriptors. As a
        /// compromise, we have to pop file descriptors using a shared
        /// reference. Implementations would have to use a RefCell, a
        /// Mutex, or something similar.
        fn fds(&self) -> &[RawFd];
        fn buffer(&self) -> &[u8];
        fn consume(self: Pin<&mut Self>, amt: usize, amt_fd: usize);
    }

    pub struct FillBufUtil<'a, R: Unpin + ?Sized>(Option<&'a mut R>, usize);

    impl<'a, R: AsyncBufReadWithFd + Unpin> ::std::future::Future for FillBufUtil<'a, R> {
        type Output = Result<()>;

        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            let this = &mut *self;
            let len = this.1;
            let inner = this.0.take().expect("FillBufUtil polled after completion");
            match Pin::new(&mut *inner).poll_fill_buf_until(cx, len) {
                Poll::Pending => {
                    this.0 = Some(inner);
                    Poll::Pending
                },
                ready => ready,
            }
        }
    }

    pub type NextMessageFut<'a, T: AsyncBufReadWithFd + 'a> =
        impl Future<Output = Result<(u32, usize, &'a [u8], &'a [RawFd])>> + 'a;
    pub trait AsyncBufReadWithFdExt: AsyncBufReadWithFd {
        fn fill_buf_until<'a>(self: &'a mut Self, len: usize) -> FillBufUtil<'a, Self>
        where
            Self: Unpin,
        {
            FillBufUtil(Some(self), len)
        }

        fn poll_next_message<'a>(
            mut self: Pin<&'a mut Self>,
            cx: &mut Context<'_>,
        ) -> Poll<Result<(u32, usize, &'a [u8], &'a [RawFd])>> {
            // Wait until we have the message header ready at least.
            let (object_id, len) = {
                ready!(self.as_mut().poll_fill_buf_until(cx, 8))?;
                let object_id = self
                    .buffer()
                    .get(..4)
                    .expect("Bug in poll_fill_buf_until implementation");
                // Safety: get is guaranteed to return a slice of 4 bytes.
                let object_id =
                    unsafe { u32::from_ne_bytes(*(object_id.as_ptr() as *const [u8; 4])) };
                let header = self
                    .buffer()
                    .get(4..8)
                    .expect("Bug in poll_fill_buf_until implementation");
                let header = unsafe { u32::from_ne_bytes(*(header.as_ptr() as *const [u8; 4])) };
                (object_id, (header >> 16) as usize)
            };

            ready!(self.as_mut().poll_fill_buf_until(cx, len))?;
            let this = self.into_ref().get_ref();
            Poll::Ready(Ok((object_id, len, &this.buffer()[..len], this.fds())))
        }

        fn next_message<'a>(self: Pin<&'a mut Self>) -> NextMessageFut<'a, Self>
        where
            Self: Sized,
        {
            pub struct NextMessage<'a, R>(Option<Pin<&'a mut R>>);
            impl<'a, R> Future for NextMessage<'a, R>
            where
                R: AsyncBufReadWithFd,
            {
                type Output = Result<(u32, usize, &'a [u8], &'a [RawFd])>;

                fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
                    let this = self.get_mut();
                    let mut reader = this.0.take().expect("NextMessage polled after completion");
                    match reader.as_mut().poll_next_message(cx) {
                        Poll::Pending => {
                            this.0 = Some(reader);
                            Poll::Pending
                        },
                        Poll::Ready(Ok(_)) => match reader.poll_next_message(cx) {
                            Poll::Pending => {
                                panic!("poll_next_message returned Ready, but then Pending again")
                            },
                            ready => ready,
                        },
                        Poll::Ready(Err(e)) => Poll::Ready(Err(e)),
                    }
                }
            }
            NextMessage(Some(self))
        }
    }

    impl<T: AsyncBufReadWithFd + ?Sized> AsyncBufReadWithFdExt for T {}

    pub trait AsyncBufWriteWithFd: AsyncWriteWithFd {
        /// Waits until there are at least `demand` bytes available in the
        /// buffer, and `demand_fd` available slots in the file
        /// descriptor buffer. Implementation shold first try to flush
        /// the buffer, until enough free space is available. If buffer
        /// is not big enough after a complete flush, it should allocate
        /// more space.
        fn poll_reserve(
            self: Pin<&mut Self>,
            cx: &mut Context<'_>,
            demand: usize,
            demand_fd: usize,
        ) -> Poll<Result<()>>;

        fn poll_flush(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<()>>;

        /// Write data into the buffer, until the buffer is full. This function
        /// should just do memory copy and cannot fail. Return the number of
        /// bytes accepted.
        fn try_write(self: Pin<&mut Self>, buf: &[u8]) -> usize;

        /// Move file descriptor into the buffer, until the buffer is full.
        /// Return the number of file descriptors accepted.
        fn try_push_fds(self: Pin<&mut Self>, fds: &mut impl Iterator<Item = OwnedFd>) -> usize;
    }

    pub struct Reserve<'a, W: ?Sized>(Pin<&'a mut W>, (usize, usize));

    impl<'a, W: AsyncBufWriteWithFd + Unpin + ?Sized> Future for Reserve<'a, W> {
        type Output = Result<()>;

        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            let (demand, demand_fd) = self.1;
            // Poll to ready with a dummy write function, because we can only use the
            // function once, and we can't lose it if we return Poll::Pending.
            self.0.as_mut().poll_reserve(cx, demand, demand_fd)
        }
    }

    type Flush<'a, T: Unpin + AsyncBufWriteWithFd + 'a> = impl Future<Output = Result<()>> + 'a;

    pub trait AsyncBufWriteWithFdExt: AsyncBufWriteWithFd {
        fn reserve(&mut self, demand: usize, demand_fd: usize) -> Reserve<'_, Self>
        where
            Self: Unpin,
        {
            Reserve(Pin::new(self), (demand, demand_fd))
        }
        fn flush(&mut self) -> Flush<'_, Self>
        where
            Self: Unpin + Sized,
        {
            struct Flush<'a, W: ?Sized>(Pin<&'a mut W>);

            impl<'a, W: AsyncBufWriteWithFd + Unpin + ?Sized> Future for Flush<'a, W> {
                type Output = Result<()>;

                fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
                    self.0.as_mut().poll_flush(cx)
                }
            }

            Flush(Pin::new(self))
        }
    }

    impl<T: AsyncBufWriteWithFd + ?Sized> AsyncBufWriteWithFdExt for T {}
}
